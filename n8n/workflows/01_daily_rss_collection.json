{
  "name": "01. Daily RSS Feed Collection (Improved)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 7 * * *"
            }
          ]
        }
      },
      "id": "daily-cron-7am",
      "name": "Daily Cron (7 AM)",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [300, 300]
    },
    {
      "parameters": {
        "authentication": "serviceAccount",
        "resource": "sheet",
        "operation": "read",
        "documentId": {
          "__rl": true,
          "value": "{{ $env.GOOGLE_SHEETS_SPREADSHEET_ID }}",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "Channel List",
          "mode": "name"
        },
        "options": {
          "range": "A:E"
        }
      },
      "id": "read-channel-list",
      "name": "Read Channel List from Google Sheets",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "position": [500, 300]
    },
    {
      "parameters": {
        "jsCode": "// ì±„ë„ ëª©ë¡ì—ì„œ RSS í”¼ë“œ URL ìƒì„± ë° ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì¤€ë¹„\nconst channelData = $input.all();\nconst rssUrls = [];\n\nfor (const row of channelData) {\n  const channelId = row.json.channel_id;\n  const channelName = row.json.channel_name;\n  const channelType = row.json.channel_type;\n  const status = row.json.status;\n  const celebrityName = row.json.celebrity_name;\n  \n  // í™œì„± ìƒíƒœì¸ ì±„ë„ë§Œ ì²˜ë¦¬\n  if (status === 'active' && channelId) {\n    rssUrls.push({\n      channel_id: channelId,\n      channel_name: channelName,\n      channel_type: channelType,\n      celebrity_name: celebrityName,\n      rss_url: `https://www.youtube.com/feeds/videos.xml?channel_id=${channelId}`,\n      retry_count: 0,\n      max_retries: 3\n    });\n  }\n}\n\n// ë°°ì¹˜ í¬ê¸° ì„¤ì • (í•œ ë²ˆì— 5ê°œì”© ì²˜ë¦¬)\nconst batchSize = 5;\nconst batches = [];\n\nfor (let i = 0; i < rssUrls.length; i += batchSize) {\n  const batch = rssUrls.slice(i, i + batchSize);\n  batches.push({\n    batch_id: Math.floor(i / batchSize) + 1,\n    total_batches: Math.ceil(rssUrls.length / batchSize),\n    urls: batch,\n    delay_before_batch: i > 0 ? 2000 : 0 // ì²« ë²ˆì§¸ ë°°ì¹˜ ì œì™¸í•˜ê³  2ì´ˆ ì§€ì—°\n  });\n}\n\nconsole.log(`í™œì„± ì±„ë„ ${rssUrls.length}ê°œë¥¼ ${batches.length}ê°œ ë°°ì¹˜ë¡œ ë‚˜ëˆ„ì–´ ì²˜ë¦¬`);\n\nreturn batches.map(batch => ({ json: batch }));"
      },
      "id": "prepare-batched-urls",
      "name": "Prepare Batched RSS URLs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [700, 300]
    },
    {
      "parameters": {
        "jsCode": "// ë°°ì¹˜ ì²˜ë¦¬ ì „ ì§€ì—° ì‹œê°„ ì ìš©\nconst batchData = $json;\nif (batchData.delay_before_batch > 0) {\n  console.log(`ë°°ì¹˜ ${batchData.batch_id} ì²˜ë¦¬ ì „ ${batchData.delay_before_batch}ms ëŒ€ê¸°`);\n  await new Promise(resolve => setTimeout(resolve, batchData.delay_before_batch));\n}\n\nconsole.log(`ë°°ì¹˜ ${batchData.batch_id}/${batchData.total_batches} ì²˜ë¦¬ ì‹œì‘ (${batchData.urls.length}ê°œ URL)`);\n\n// ë°°ì¹˜ ë‚´ ê° URLì„ ê°œë³„ ì•„ì´í…œìœ¼ë¡œ ì¶œë ¥\nreturn batchData.urls.map(url => ({ json: url }));"
      },
      "id": "batch-delay-handler",
      "name": "Handle Batch Delays",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.rss_url }}",
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxAttempts": 3,
            "waitBetween": 1000
          },
          "response": {
            "neverError": true
          }
        }
      },
      "id": "fetch-rss-feed",
      "name": "Fetch RSS Feed (Enhanced)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1100, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "response-exists",
              "leftValue": "={{ $json.body }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "isNotEmpty"
              }
            },
            {
              "id": "status-ok",
              "leftValue": "={{ $json.statusCode }}",
              "rightValue": "200",
              "operator": {
                "type": "number",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "validate-rss-response",
      "name": "Validate RSS Response",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1300, 300]
    },
    {
      "parameters": {
        "jsCode": "// RSS XML ìœ íš¨ì„± ê²€ì‚¬ ë° íŒŒì‹±\nconst rssXml = $json.body;\nconst channelInfo = $('Handle Batch Delays').item.json;\nconst requestInfo = $json;\n\n// XML ìœ íš¨ì„± ê²€ì‚¬\nlet isValidXml = false;\nlet errorMessage = '';\n\ntry {\n  // ê¸°ë³¸ XML êµ¬ì¡° ê²€ì‚¬\n  if (rssXml && typeof rssXml === 'string' && rssXml.includes('<feed') && rssXml.includes('</feed>')) {\n    isValidXml = true;\n  } else if (rssXml && rssXml.includes('<rss') && rssXml.includes('</rss>')) {\n    isValidXml = true;\n  } else {\n    errorMessage = 'Invalid XML format - missing feed or rss root element';\n  }\n} catch (error) {\n  errorMessage = `XML validation error: ${error.message}`;\n}\n\nif (!isValidXml) {\n  console.error(`RSS í”¼ë“œ ê²€ì¦ ì‹¤íŒ¨ - ${channelInfo.channel_name}: ${errorMessage}`);\n  return [{\n    json: {\n      success: false,\n      channel_info: channelInfo,\n      error: errorMessage,\n      request_info: {\n        status_code: requestInfo.statusCode,\n        content_type: requestInfo.headers?.['content-type'],\n        response_size: rssXml ? rssXml.length : 0\n      }\n    }\n  }];\n}\n\n// RSS XML íŒŒì‹±í•˜ì—¬ ìµœì‹  ì˜ìƒ ì¶”ì¶œ\nconst DOMParser = require('xmldom').DOMParser;\nlet newVideos = [];\nlet parseError = null;\n\ntry {\n  const parser = new DOMParser({\n    errorHandler: {\n      warning: function(w) { console.warn('XML Warning:', w); },\n      error: function(e) { console.error('XML Error:', e); parseError = e; },\n      fatalError: function(e) { console.error('XML Fatal Error:', e); parseError = e; }\n    }\n  });\n  \n  const xmlDoc = parser.parseFromString(rssXml, 'text/xml');\n  \n  if (parseError) {\n    throw new Error(`XML parsing failed: ${parseError}`);\n  }\n  \n  const entries = xmlDoc.getElementsByTagName('entry');\n  \n  if (entries.length === 0) {\n    console.log(`${channelInfo.channel_name}: RSS í”¼ë“œì— í•­ëª©ì´ ì—†ìŒ`);\n  }\n  \n  // ì§€ë‚œ 24ì‹œê°„ ë‚´ ì—…ë¡œë“œëœ ì˜ìƒë§Œ í•„í„°ë§\n  const yesterday = new Date();\n  yesterday.setDate(yesterday.getDate() - 1);\n  \n  for (let i = 0; i < Math.min(entries.length, 10); i++) {\n    const entry = entries[i];\n    const videoId = entry.getElementsByTagName('yt:videoId')[0]?.textContent;\n    const title = entry.getElementsByTagName('title')[0]?.textContent;\n    const published = entry.getElementsByTagName('published')[0]?.textContent;\n    const author = entry.getElementsByTagName('author')[0]?.getElementsByTagName('name')[0]?.textContent;\n    \n    if (videoId && title && published) {\n      const publishDate = new Date(published);\n      \n      // 24ì‹œê°„ ë‚´ ì—…ë¡œë“œëœ ì˜ìƒì¸ì§€ í™•ì¸\n      if (publishDate >= yesterday) {\n        // ë¯¸ë””ì–´ ì±„ë„ì˜ ê²½ìš° ì—°ì˜ˆì¸ ì´ë¦„ì´ ì œëª©ì— í¬í•¨ëœ ê²½ìš°ë§Œ\n        let shouldInclude = true;\n        if (channelInfo.channel_type === 'media' && channelInfo.celebrity_name) {\n          shouldInclude = title.toLowerCase().includes(channelInfo.celebrity_name.toLowerCase());\n        }\n        \n        // YouTube Shorts ì œì™¸ (PRD ìš”êµ¬ì‚¬í•­)\n        const isShorts = title.toLowerCase().includes('#shorts') || \n                        title.toLowerCase().includes('shorts') ||\n                        title.includes('ğŸ©³');\n        \n        if (shouldInclude && !isShorts) {\n          newVideos.push({\n            video_id: videoId,\n            video_title: title,\n            video_url: `https://www.youtube.com/watch?v=${videoId}`,\n            channel_id: channelInfo.channel_id,\n            channel_name: channelInfo.channel_name,\n            channel_type: channelInfo.channel_type,\n            celebrity_name: channelInfo.celebrity_name,\n            published_date: published,\n            author: author,\n            discovery_date: new Date().toISOString(),\n            success: true\n          });\n        }\n      }\n    }\n  }\n} catch (error) {\n  console.error(`RSS íŒŒì‹± ì˜¤ë¥˜ - ${channelInfo.channel_name}:`, error);\n  return [{\n    json: {\n      success: false,\n      channel_info: channelInfo,\n      error: `RSS parsing failed: ${error.message}`,\n      request_info: {\n        status_code: requestInfo.statusCode,\n        content_type: requestInfo.headers?.['content-type'],\n        response_size: rssXml ? rssXml.length : 0\n      }\n    }\n  }];\n}\n\nconsole.log(`${channelInfo.channel_name}: ${newVideos.length}ê°œ ì‹ ê·œ ì˜ìƒ ë°œê²¬`);\n\nif (newVideos.length === 0) {\n  return [{\n    json: {\n      success: true,\n      channel_info: channelInfo,\n      new_videos_count: 0,\n      message: 'No new videos found in the last 24 hours'\n    }\n  }];\n}\n\nreturn newVideos.map(video => ({ json: video }));"
      },
      "id": "parse-and-validate-rss",
      "name": "Parse and Validate RSS Feed",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1500, 200]
    },
    {
      "parameters": {
        "jsCode": "// RSS í”¼ë“œ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨ ì²˜ë¦¬ ë° ì¬ì‹œë„ ë¡œì§\nconst channelInfo = $('Handle Batch Delays').item.json;\nconst responseInfo = $json;\n\nconst failureInfo = {\n  channel_id: channelInfo.channel_id,\n  channel_name: channelInfo.channel_name,\n  rss_url: channelInfo.rss_url,\n  retry_count: channelInfo.retry_count + 1,\n  max_retries: channelInfo.max_retries,\n  error_details: {\n    status_code: responseInfo.statusCode || 'unknown',\n    error_message: responseInfo.error || 'No response received',\n    timestamp: new Date().toISOString()\n  }\n};\n\nconsole.error(`RSS í”¼ë“œ ì‹¤íŒ¨ - ${channelInfo.channel_name}: Status ${responseInfo.statusCode || 'N/A'}`);\n\n// ì¬ì‹œë„ ê°€ëŠ¥í•œì§€ í™•ì¸\nif (failureInfo.retry_count < failureInfo.max_retries) {\n  // ì§€ìˆ˜ì  ë°±ì˜¤í”„ ê³„ì‚° (1ì´ˆ, 2ì´ˆ, 4ì´ˆ)\n  const backoffDelay = Math.pow(2, failureInfo.retry_count) * 1000;\n  \n  console.log(`${channelInfo.channel_name}: ${backoffDelay}ms í›„ ì¬ì‹œë„ (${failureInfo.retry_count}/${failureInfo.max_retries})`);\n  \n  // ì§€ì—° í›„ ì¬ì‹œë„ë¥¼ ìœ„í•œ ì •ë³´ ë°˜í™˜\n  return [{\n    json: {\n      ...channelInfo,\n      retry_count: failureInfo.retry_count,\n      backoff_delay: backoffDelay,\n      should_retry: true\n    }\n  }];\n} else {\n  // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ë„ë‹¬\n  console.error(`${channelInfo.channel_name}: ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ë„ë‹¬, ì‹¤íŒ¨ ì²˜ë¦¬`);\n  \n  return [{\n    json: {\n      success: false,\n      channel_info: channelInfo,\n      final_failure: true,\n      error: `Failed after ${failureInfo.max_retries} retries`,\n      last_error: failureInfo.error_details\n    }\n  }];\n}"
      },
      "id": "handle-rss-failure",
      "name": "Handle RSS Fetch Failure",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1500, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "should-retry",
              "leftValue": "={{ $json.should_retry }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-retry-needed",
      "name": "Check If Retry Needed",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1700, 400]
    },
    {
      "parameters": {
        "jsCode": "// ì¬ì‹œë„ ì „ ë°±ì˜¤í”„ ì§€ì—° ì ìš©\nconst retryInfo = $json;\n\nif (retryInfo.backoff_delay > 0) {\n  console.log(`${retryInfo.channel_name}: ${retryInfo.backoff_delay}ms ë°±ì˜¤í”„ ì§€ì—° ì ìš©`);\n  await new Promise(resolve => setTimeout(resolve, retryInfo.backoff_delay));\n}\n\nreturn [{ json: retryInfo }];"
      },
      "id": "apply-backoff-delay",
      "name": "Apply Exponential Backoff",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1900, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-new-videos",
              "leftValue": "={{ $json.success }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            },
            {
              "id": "has-video-id",
              "leftValue": "={{ $json.video_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "isNotEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-new-videos",
      "name": "Check If New Videos Found",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1700, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "{{ $env.CHANNEL_DISCOVERY_API_URL || 'http://localhost:5001' }}/analyze/video",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "video_url",
              "value": "={{ $json.video_url }}"
            },
            {
              "name": "video_id",
              "value": "={{ $json.video_id }}"
            },
            {
              "name": "channel_info",
              "value": "={{ JSON.stringify({channel_id: $json.channel_id, channel_name: $json.channel_name, channel_type: $json.channel_type, celebrity_name: $json.celebrity_name}) }}"
            },
            {
              "name": "priority",
              "value": "normal"
            }
          ]
        },
        "options": {
          "timeout": 120000
        }
      },
      "id": "trigger-video-analysis",
      "name": "Trigger Video Analysis",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1900, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "{{ $env.SLACK_WEBHOOK_URL }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "ğŸ“º ìƒˆë¡œìš´ ì˜ìƒ ë°œê²¬!"
            },
            {
              "name": "blocks",
              "value": "={{ JSON.stringify([{\"type\": \"header\", \"text\": {\"type\": \"plain_text\", \"text\": \"ğŸ“º ìƒˆë¡œìš´ ì˜ìƒ ë°œê²¬!\"}}, {\"type\": \"section\", \"fields\": [{\"type\": \"mrkdwn\", \"text\": \"*ì±„ë„:*\\n\" + $json.channel_name}, {\"type\": \"mrkdwn\", \"text\": \"*ì—°ì˜ˆì¸:*\\n\" + ($json.celebrity_name || 'N/A')}, {\"type\": \"mrkdwn\", \"text\": \"*ì˜ìƒ ì œëª©:*\\n\" + $json.video_title}, {\"type\": \"mrkdwn\", \"text\": \"*ì—…ë¡œë“œ:*\\n\" + new Date($json.published_date).toLocaleString('ko-KR')}]}, {\"type\": \"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": \"ğŸ”— <\" + $json.video_url + \"|ì˜ìƒ ë³´ê¸°> | ğŸ¤– ë¶„ì„ ì‹œì‘ë¨\"}}, {\"type\": \"context\", \"elements\": [{\"type\": \"mrkdwn\", \"text\": \"ğŸ“… \" + new Date().toLocaleString('ko-KR') + \" | ğŸ¤– ìë™ ìˆ˜ì§‘ (Enhanced)\"}]}]) }}"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "notify-new-video",
      "name": "Notify New Video Found",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1900, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "{{ $env.SLACK_WEBHOOK_URL }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "âš ï¸ RSS í”¼ë“œ ì²˜ë¦¬ ì˜¤ë¥˜ ë°œìƒ"
            },
            {
              "name": "blocks",
              "value": "={{ JSON.stringify([{\"type\": \"header\", \"text\": {\"type\": \"plain_text\", \"text\": \"âš ï¸ RSS í”¼ë“œ ì²˜ë¦¬ ì˜¤ë¥˜\"}}, {\"type\": \"section\", \"fields\": [{\"type\": \"mrkdwn\", \"text\": \"*ì±„ë„:*\\n\" + $json.channel_info.channel_name}, {\"type\": \"mrkdwn\", \"text\": \"*ì˜¤ë¥˜:*\\n\" + $json.error}, {\"type\": \"mrkdwn\", \"text\": \"*ì¬ì‹œë„:*\\n\" + ($json.final_failure ? 'ìµœëŒ€ ì¬ì‹œë„ ë„ë‹¬' : 'ì¬ì‹œë„ ì¤‘')}, {\"type\": \"mrkdwn\", \"text\": \"*ì‹œê°„:*\\n\" + new Date().toLocaleString('ko-KR')}]}, {\"type\": \"context\", \"elements\": [{\"type\": \"mrkdwn\", \"text\": \"ğŸ”§ ê´€ë¦¬ì í™•ì¸ í•„ìš” | RSS URL: \" + $json.channel_info.rss_url}]}]) }}"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "notify-rss-failure",
      "name": "Notify RSS Failure",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1900, 500]
    },
    {
      "parameters": {
        "jsCode": "// ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ìš”ì•½ ìƒì„±\nconst allInputs = $input.all();\n\nlet successCount = 0;\nlet failureCount = 0;\nlet newVideoCount = 0;\nlet processedChannels = [];\nlet failedChannels = [];\n\nfor (const input of allInputs) {\n  const data = input.json;\n  \n  if (data.success === false && data.final_failure) {\n    failureCount++;\n    failedChannels.push({\n      name: data.channel_info.channel_name,\n      error: data.error\n    });\n  } else if (data.success === true || data.video_id) {\n    successCount++;\n    if (data.video_id) {\n      newVideoCount++;\n    }\n    processedChannels.push(data.channel_name || data.channel_info?.channel_name);\n  }\n}\n\nconst summary = {\n  execution_time: new Date().toISOString(),\n  total_processed: successCount + failureCount,\n  successful_channels: successCount,\n  failed_channels: failureCount,\n  new_videos_found: newVideoCount,\n  processed_channel_names: [...new Set(processedChannels)],\n  failed_channel_details: failedChannels\n};\n\nconsole.log('RSS ìˆ˜ì§‘ ìš”ì•½:', JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];"
      },
      "id": "generate-summary",
      "name": "Generate Execution Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2100, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "{{ $env.SLACK_WEBHOOK_URL }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "âœ… ì¼ì¼ RSS ìˆ˜ì§‘ ì™„ë£Œ (Enhanced)"
            },
            {
              "name": "blocks",
              "value": "={{ JSON.stringify([{\"type\": \"header\", \"text\": {\"type\": \"plain_text\", \"text\": \"âœ… ì¼ì¼ RSS ìˆ˜ì§‘ ì™„ë£Œ (Enhanced)\"}}, {\"type\": \"section\", \"fields\": [{\"type\": \"mrkdwn\", \"text\": \"*ì²˜ë¦¬ëœ ì±„ë„:*\\n\" + $json.successful_channels + \"ê°œ\"}, {\"type\": \"mrkdwn\", \"text\": \"*ì‹¤íŒ¨í•œ ì±„ë„:*\\n\" + $json.failed_channels + \"ê°œ\"}, {\"type\": \"mrkdwn\", \"text\": \"*ì‹ ê·œ ì˜ìƒ:*\\n\" + $json.new_videos_found + \"ê°œ\"}, {\"type\": \"mrkdwn\", \"text\": \"*ì´ ì²˜ë¦¬:*\\n\" + $json.total_processed + \"ê°œ ì±„ë„\"}]}, ($json.failed_channels > 0 ? {\"type\": \"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": \"âš ï¸ *ì‹¤íŒ¨í•œ ì±„ë„ë“¤:*\\n\" + $json.failed_channel_details.map(ch => \"â€¢ \" + ch.name + \": \" + ch.error).join(\"\\n\")}} : {}), {\"type\": \"context\", \"elements\": [{\"type\": \"mrkdwn\", \"text\": \"ğŸ“… \" + new Date().toLocaleString('ko-KR') + \" | ğŸ”§ Enhanced with error handling & retry logic\"}]}]) }}"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "notify-final-summary",
      "name": "Notify Final Summary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2300, 300]
    }
  ],
  "connections": {
    "Daily Cron (7 AM)": {
      "main": [
        [
          {
            "node": "Read Channel List from Google Sheets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Channel List from Google Sheets": {
      "main": [
        [
          {
            "node": "Prepare Batched RSS URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Batched RSS URLs": {
      "main": [
        [
          {
            "node": "Handle Batch Delays",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Batch Delays": {
      "main": [
        [
          {
            "node": "Fetch RSS Feed (Enhanced)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch RSS Feed (Enhanced)": {
      "main": [
        [
          {
            "node": "Validate RSS Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate RSS Response": {
      "main": [
        [
          {
            "node": "Parse and Validate RSS Feed",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle RSS Fetch Failure",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse and Validate RSS Feed": {
      "main": [
        [
          {
            "node": "Check If New Videos Found",
            "type": "main",
            "index": 0
          },
          {
            "node": "Generate Execution Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle RSS Fetch Failure": {
      "main": [
        [
          {
            "node": "Check If Retry Needed",
            "type": "main",
            "index": 0
          },
          {
            "node": "Generate Execution Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If Retry Needed": {
      "main": [
        [
          {
            "node": "Apply Exponential Backoff",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Notify RSS Failure",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Exponential Backoff": {
      "main": [
        [
          {
            "node": "Fetch RSS Feed (Enhanced)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If New Videos Found": {
      "main": [
        [
          {
            "node": "Trigger Video Analysis",
            "type": "main",
            "index": 0
          },
          {
            "node": "Notify New Video Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Execution Summary": {
      "main": [
        [
          {
            "node": "Notify Final Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "createdAt": "2025-06-27T07:00:00.000Z",
  "updatedAt": "2025-06-27T07:00:00.000Z",
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": {
      "enabled": false
    }
  },
  "staticData": {},
  "tags": [
    {
      "name": "enhanced",
      "id": "enhanced-rss"
    },
    {
      "name": "error-handling",
      "id": "error-handling"
    }
  ]
}